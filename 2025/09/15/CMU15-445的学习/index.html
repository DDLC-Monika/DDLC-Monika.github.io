<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CMU15-445的学习 | Sakuya的算法基地</title><meta name="author" content="Sakuya_maid"><meta name="copyright" content="Sakuya_maid"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="手写数据库内核：CMU 15-445 (BusTub) 复盘 项目概览  项目名称：BusTub (CMU 15-445 Database Systems 课程实验室项目) 技术栈：C++17, GTest, Linux 核心架构：面向磁盘（Disk-Oriented）的关系型数据库 一句话简介：从零开始实现一个支持 SQL 的数据库内核，涵盖内存管理、索引结构、算子执行到并发控制的完整链路。">
<meta property="og:type" content="article">
<meta property="og:title" content="CMU15-445的学习">
<meta property="og:url" content="http://example.com/2025/09/15/CMU15-445%E7%9A%84%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Sakuya的算法基地">
<meta property="og:description" content="手写数据库内核：CMU 15-445 (BusTub) 复盘 项目概览  项目名称：BusTub (CMU 15-445 Database Systems 课程实验室项目) 技术栈：C++17, GTest, Linux 核心架构：面向磁盘（Disk-Oriented）的关系型数据库 一句话简介：从零开始实现一个支持 SQL 的数据库内核，涵盖内存管理、索引结构、算子执行到并发控制的完整链路。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/e69f040cf614d996afe704ea41c637ab.jpg">
<meta property="article:published_time" content="2025-09-15T02:00:00.000Z">
<meta property="article:modified_time" content="2026-01-16T09:46:49.494Z">
<meta property="article:author" content="Sakuya_maid">
<meta property="article:tag" content="树论">
<meta property="article:tag" content="B+ Tree">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="锁">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/e69f040cf614d996afe704ea41c637ab.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CMU15-445的学习",
  "url": "http://example.com/2025/09/15/CMU15-445%E7%9A%84%E5%AD%A6%E4%B9%A0/",
  "image": "http://example.com/img/e69f040cf614d996afe704ea41c637ab.jpg",
  "datePublished": "2025-09-15T02:00:00.000Z",
  "dateModified": "2026-01-16T09:46:49.494Z",
  "author": [
    {
      "@type": "Person",
      "name": "Sakuya_maid",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/09/15/CMU15-445%E7%9A%84%E5%AD%A6%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4-b1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CMU15-445的学习',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/img1.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Sakuya的算法基地</span></a><a class="nav-page-title" href="/"><span class="site-name">CMU15-445的学习</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">CMU15-445的学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-15T02:00:00.000Z" title="发表于 2025-09-15 10:00:00">2025-09-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-01-16T09:46:49.494Z" title="更新于 2026-01-16 17:46:49">2026-01-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/">项目学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="手写数据库内核：CMU-15-445-BusTub-复盘"><a href="#手写数据库内核：CMU-15-445-BusTub-复盘" class="headerlink" title="手写数据库内核：CMU 15-445 (BusTub) 复盘"></a>手写数据库内核：CMU 15-445 (BusTub) 复盘</h1><blockquote>
<p><strong>项目概览</strong></p>
<ul>
<li><strong>项目名称</strong>：BusTub (CMU 15-445 Database Systems 课程实验室项目)</li>
<li><strong>技术栈</strong>：C++17, GTest, Linux</li>
<li><strong>核心架构</strong>：面向磁盘（Disk-Oriented）的关系型数据库</li>
<li><strong>一句话简介</strong>：从零开始实现一个支持 SQL 的数据库内核，涵盖内存管理、索引结构、算子执行到并发控制的完整链路。</li>
</ul>
</blockquote>
<p>以下是我对四个核心模块的深度复盘与踩坑记录。</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟磁盘页面</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Page</span> &#123;</span><br><span class="line">    <span class="type">page_id_t</span> page_id_ = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> data_[<span class="number">1024</span>] = &#123;&#125;; <span class="comment">// 模拟存储数据</span></span><br><span class="line">    <span class="type">bool</span> is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> pin_count_ = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// P2: B+树并发控制需要的读写锁 (Latch)</span></span><br><span class="line">    std::shared_mutex rwlatch_;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RLatch</span><span class="params">()</span> </span>&#123; rwlatch_.<span class="built_in">lock_shared</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RUnlatch</span><span class="params">()</span> </span>&#123; rwlatch_.<span class="built_in">unlock_shared</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">WLatch</span><span class="params">()</span> </span>&#123; rwlatch_.<span class="built_in">lock</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">WUnlatch</span><span class="params">()</span> </span>&#123; rwlatch_.<span class="built_in">unlock</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        page_id_ = <span class="number">-1</span>;</span><br><span class="line">        is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">        pin_count_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Project-1-Buffer-Pool-Manager"><a href="#Project-1-Buffer-Pool-Manager" class="headerlink" title="Project 1: Buffer Pool Manager"></a>Project 1: Buffer Pool Manager</h2><p>这是数据库与磁盘交互的第一道防线。我们都知道磁盘 I/O 是极慢的，而内存是昂贵的。Buffer Pool 的核心使命就是：<strong>用有限的内存空间，制造出一种“数据都在内存里”的假象。</strong></p>
<h3 id="1-核心挑战：LRU-K-置换算法"><a href="#1-核心挑战：LRU-K-置换算法" class="headerlink" title="1. 核心挑战：LRU-K 置换算法"></a>1. 核心挑战：LRU-K 置换算法</h3><p>在实现页面置换策略时，课程要求放弃传统的 LRU，改用 <strong>LRU-K</strong>。 起初我不理解为什么要搞得这么复杂，后来才明白传统 LRU 的致命弱点——<strong>Buffer Pool Pollution（缓存污染）</strong>。当数据库执行一次“全表扫描（Sequential Scan）”时，大量只会被访问一次的数据会瞬间冲垮缓存，把真正的热点数据挤出去。</p>
<p><strong>我的实现思路：</strong></p>
<ul>
<li><strong>K=2 的哲学</strong>：我将逻辑分为两个队列，“历史队列”和“缓存队列”。</li>
<li><strong>规则</strong>：一个页面只有被访问了 K 次（通常 K=2），才有资格进入“缓存队列”。如果访问次数不足 K，它通过 FIFO 或 LRU 淘汰。</li>
<li><strong>淘汰策略</strong>：在缓存队列中，我们通过计算“倒数第 K 次访问的时间戳”与当前时间的距离（Backward K-distance），距离最大的那个就是最该被淘汰的。这让系统对突发性的扫描操作有了极强的抵抗力。</li>
</ul>
<h3 id="2-内存映射与-Pin-Unpin-机制"><a href="#2-内存映射与-Pin-Unpin-机制" class="headerlink" title="2. 内存映射与 Pin/Unpin 机制"></a>2. 内存映射与 Pin/Unpin 机制</h3><p>这是最容易导致 Memory Leak 的地方。我维护了一个 <code>Page Table</code>（本质是 <code>std::unordered_map</code>），负责将磁盘上的 <code>Page ID</code> 映射到内存中的 <code>Frame ID</code>。</p>
<p>这里最重要的概念是 <strong>Pin (钉住)</strong>：</p>
<ul>
<li><strong>Pin</strong>：当上层线程要读写一个页面时，必须 Pin 住它。这相当于告诉 Buffer Pool：“这页我在用，千万别把它写回磁盘！”</li>
<li><strong>Unpin</strong>：用完了必须显式 Unpin。如果期间修改了数据，还需要标记 <code>dirty</code> 位，这样置换时才会刷盘。</li>
</ul>
<p><strong>踩坑点</strong>：并发安全。整个 Buffer Pool 需要一把全局大锁（Latch）。但在高并发下这是瓶颈，后期我尝试引入了 <code>std::shared_mutex</code> 来做读写分离，或者考虑分段锁（Partitioned Buffer Pool）来优化。</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUKReplacer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 简单模拟 LRU：最近访问的放到链表尾部</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RecordAccess</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果存在，移除旧位置</span></span><br><span class="line">        <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(lru_list_.<span class="built_in">begin</span>(), lru_list_.<span class="built_in">end</span>(), frame_id);</span><br><span class="line">        <span class="keyword">if</span> (it != lru_list_.<span class="built_in">end</span>()) lru_list_.<span class="built_in">erase</span>(it);</span><br><span class="line">        <span class="comment">// 放到末尾（表示最近使用）</span></span><br><span class="line">        lru_list_.<span class="built_in">push_back</span>(frame_id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Evict</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lru_list_.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        *frame_id = lru_list_.<span class="built_in">front</span>(); <span class="comment">// 踢出最老的（头部）</span></span><br><span class="line">        lru_list_.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Remove</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(lru_list_.<span class="built_in">begin</span>(), lru_list_.<span class="built_in">end</span>(), frame_id);</span><br><span class="line">        <span class="keyword">if</span> (it != lru_list_.<span class="built_in">end</span>()) lru_list_.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::list&lt;<span class="type">frame_id_t</span>&gt; lru_list_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferPoolManager</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BufferPoolManager</span>(<span class="type">size_t</span> pool_size) : <span class="built_in">pool_size_</span>(pool_size) &#123;</span><br><span class="line">        pages_ = <span class="keyword">new</span> Page[pool_size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; pool_size; ++i) free_list_.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">BufferPoolManager</span>() &#123; <span class="keyword">delete</span>[] pages_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Page *<span class="title">FetchPage</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>; <span class="comment">// 必须加锁保护 Page Table</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 缓存命中 (Cache Hit)</span></span><br><span class="line">        <span class="keyword">if</span> (page_table_.<span class="built_in">count</span>(page_id)) &#123;</span><br><span class="line">            <span class="type">frame_id_t</span> frame = page_table_[page_id];</span><br><span class="line">            pages_[frame].pin_count_++;</span><br><span class="line">            replacer_.<span class="built_in">Remove</span>(frame); <span class="comment">// Pin 住的页面不能在 LRU 列表中</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;[BPM] Hit Page &quot;</span> &lt;&lt; page_id &lt;&lt; <span class="string">&quot; (PinCount: &quot;</span> &lt;&lt; pages_[frame].pin_count_ &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> &amp;pages_[frame];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 缓存未命中 (Cache Miss) -&gt; 需要驱逐 (Evict)</span></span><br><span class="line">        <span class="type">frame_id_t</span> frame;</span><br><span class="line">        <span class="keyword">if</span> (!free_list_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            frame = free_list_.<span class="built_in">front</span>(); free_list_.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!replacer_.<span class="built_in">Evict</span>(&amp;frame)) <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 所有页面都被 Pin 了</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果是脏页，模拟写回磁盘</span></span><br><span class="line">            Page &amp;victim = pages_[frame];</span><br><span class="line">            <span class="keyword">if</span> (victim.is_dirty_) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;[Disk] WriteBack Dirty Page &quot;</span> &lt;&lt; victim.page_id_ &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            page_table_.<span class="built_in">erase</span>(victim.page_id_);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;[BPM] Evicted Page &quot;</span> &lt;&lt; victim.page_id_ &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 从磁盘读入新页</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[Disk] Reading Page &quot;</span> &lt;&lt; page_id &lt;&lt; <span class="string">&quot; -&gt; Frame &quot;</span> &lt;&lt; frame &lt;&lt; endl;</span><br><span class="line">        pages_[frame].<span class="built_in">Reset</span>();</span><br><span class="line">        pages_[frame].page_id_ = page_id;</span><br><span class="line">        pages_[frame].pin_count_ = <span class="number">1</span>;</span><br><span class="line">        page_table_[page_id] = frame;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &amp;pages_[frame];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">UnpinPage</span><span class="params">(<span class="type">page_id_t</span> page_id, <span class="type">bool</span> is_dirty)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!page_table_.<span class="built_in">count</span>(page_id)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">frame_id_t</span> frame = page_table_[page_id];</span><br><span class="line">        <span class="keyword">if</span> (pages_[frame].pin_count_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            pages_[frame].pin_count_--;</span><br><span class="line">            <span class="keyword">if</span> (is_dirty) pages_[frame].is_dirty_ = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果 Pin Count 归零，加入 LRU 列表等待被踢</span></span><br><span class="line">            <span class="keyword">if</span> (pages_[frame].pin_count_ == <span class="number">0</span>) &#123;</span><br><span class="line">                replacer_.<span class="built_in">RecordAccess</span>(frame);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FlushAllPages</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;[BPM] Flushing all dirty pages to disk...&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> pool_size_;</span><br><span class="line">    Page *pages_;</span><br><span class="line">    LRUKReplacer replacer_;</span><br><span class="line">    std::list&lt;<span class="type">frame_id_t</span>&gt; free_list_;</span><br><span class="line">    std::unordered_map&lt;<span class="type">page_id_t</span>, <span class="type">frame_id_t</span>&gt; page_table_;</span><br><span class="line">    std::mutex latch_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Project-2-B-Tree-Index"><a href="#Project-2-B-Tree-Index" class="headerlink" title="Project 2: B+ Tree Index"></a>Project 2: B+ Tree Index</h2><p><img src="/images/231.png" alt="图片描述"></p>
<p><img src="/images/213.png" alt="图片描述"></p>
<p>B+ 树如图所示 叶子节点才存储着实际信息，叶子节点直接由链表直接链接，中间非叶子节点存的当前儿子的最大值，方便从根节点开始b+tree树上二分查找，当insert进去一个新的节点时候，当前（9，10，11）已经超过数量限制，所以会往上分裂，删除同理，相反即可</p>
<p>实现一个单线程的 B+ 树已经很繁琐了（各种分裂、合并、借位），更别提要支持多线程并发读写。</p>
<h3 id="1-数据结构设计"><a href="#1-数据结构设计" class="headerlink" title="1. 数据结构设计"></a>1. 数据结构设计</h3><p>B+ 树的精髓在于 <strong>Internal Page</strong> 和 <strong>Leaf Page</strong> 的分离：</p>
<ul>
<li><strong>Internal Page</strong>：只存 Key 做路标，不存 Data。</li>
<li><strong>Leaf Page</strong>：存真实的 Record ID，且叶子节点之间通过 <code>Next_Page_ID</code> 连成链表。这直接决定了 <code>Range Scan</code>（范围查询）的性能。</li>
</ul>
<h3 id="2-Latch-Crabbing"><a href="#2-Latch-Crabbing" class="headerlink" title="2. Latch Crabbing"></a>2. Latch Crabbing</h3><p>如何让多线程在树上跑而不撞车？我实现了 <strong>Latch Crabbing</strong> 协议。 这就好比螃蟹走路：</p>
<ol>
<li>先抓紧前一把锁（Parent）。</li>
<li>再去抓下一把锁（Child）。</li>
<li>确认抓稳 Child 后，才松开 Parent。</li>
</ol>
<p><strong>由上至下的锁流转：</strong></p>
<ul>
<li><strong>读操作 (Search)</strong>：一路加 Read Latch，拿到 Child 就放 Parent。</li>
<li><strong>写操作 (Insert/Delete)</strong>：这里我采用了<strong>乐观锁优化</strong>。<ul>
<li><strong>乐观路径</strong>：假设这次插入不会导致节点分裂。那么我一路只加 Read Latch，直到叶子节点加 Write Latch。</li>
<li><strong>悲观回退</strong>：如果到底部发现叶子满了（必须分裂），说明乐观猜测失败。立刻释放所有锁，重头来过，这次从根节点开始就加 Write Latch，直接独占整条路径。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Lock vs Latch?</strong> 面试常问点。在这个项目中，我深刻体会到：</p>
<ul>
<li><strong>Latch</strong> 是线程层面的（像 <code>std::mutex</code>），保护内存数据结构，持有时间极短，没有死锁检测。</li>
<li><strong>Lock</strong> 是事务层面的（Project 4 里的），保护数据库逻辑内容（行/表），持有时间长，需要支持回滚。</li>
</ul>
</blockquote>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BPlusTree</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BPlusTree</span>(BufferPoolManager *bpm) : <span class="built_in">bpm_</span>(bpm) &#123;</span><br><span class="line">        root_page_id_ = <span class="number">0</span>; <span class="comment">// 假设 Root 永远是 Page 0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟查询过程：演示如何加锁</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetValue</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&gt;&gt;&gt; [B+Tree] Search Key &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot; Start (Latch Crabbing) &lt;&lt;&lt;&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 1: 锁住 Root</span></span><br><span class="line">        Page *curr_page = bpm_-&gt;<span class="built_in">FetchPage</span>(root_page_id_);</span><br><span class="line">        curr_page-&gt;<span class="built_in">RLatch</span>(); <span class="comment">// 加读锁</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;  -&gt; Locked Parent (Page &quot;</span> &lt;&lt; root_page_id_ &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 2: 模拟找到子节点 (假设 Child 是 Page 1)</span></span><br><span class="line">        <span class="type">page_id_t</span> child_id = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 3: 锁住 Child (Crabbing: Hold Child, Release Parent)</span></span><br><span class="line">        Page *child_page = bpm_-&gt;<span class="built_in">FetchPage</span>(child_id);</span><br><span class="line">        child_page-&gt;<span class="built_in">RLatch</span>(); <span class="comment">// 加读锁</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;  -&gt; Locked Child (Page &quot;</span> &lt;&lt; child_id &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放 Parent</span></span><br><span class="line">        curr_page-&gt;<span class="built_in">RUnlatch</span>();</span><br><span class="line">        bpm_-&gt;<span class="built_in">UnpinPage</span>(curr_page-&gt;page_id_, <span class="literal">false</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;  -&gt; Unlocked Parent (Page &quot;</span> &lt;&lt; root_page_id_ &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 4: 在叶子节点读取数据</span></span><br><span class="line">        <span class="type">int</span> val = key * <span class="number">100</span>; <span class="comment">// 模拟读到的数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 5: 释放 Child</span></span><br><span class="line">        child_page-&gt;<span class="built_in">RUnlatch</span>();</span><br><span class="line">        bpm_-&gt;<span class="built_in">UnpinPage</span>(child_page-&gt;page_id_, <span class="literal">false</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;  -&gt; Unlocked Child (Page &quot;</span> &lt;&lt; child_id &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BufferPoolManager *bpm_;</span><br><span class="line">    <span class="type">page_id_t</span> root_page_id_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Project-3-Query-Execution"><a href="#Project-3-Query-Execution" class="headerlink" title="Project 3: Query Execution"></a>Project 3: Query Execution</h2><p>写完了存储和索引，终于到了让 SQL 跑起来的时候。这一层采用的是经典的 <strong>Volcano Model (Iterator Model)</strong>。</p>
<h3 id="1-“拉取式“执行流"><a href="#1-“拉取式“执行流" class="headerlink" title="1. “拉取式“执行流"></a>1. “拉取式“执行流</h3><p>在这个模型中，所有的算子（SeqScan, Join, Aggregation）都继承自抽象基类，并实现 <code>Init()</code> 和 <code>Next()</code>。 执行查询就像是一个<strong>流水线</strong>：</p>
<ul>
<li>根节点调用 <code>Next()</code> 索要数据。</li>
<li>父算子调用子算子的 <code>Next()</code>。</li>
<li>数据一行行（或者一个 Batch）地从底层的 Table Heap 被“拉”上来。</li>
</ul>
<p>这种设计最大的好处是<strong>内存利用率高</strong>，不需要把整张表加载到内存，而是流式处理。</p>
<h3 id="2-Join-的优化"><a href="#2-Join-的优化" class="headerlink" title="2. Join 的优化"></a>2. Join 的优化</h3><p>在实现 <code>Nested Loop Join</code> 时，最暴力的做法是两层 <code>for</code> 循环。但这会让磁盘 I/O 爆炸。</p>
<ul>
<li><strong>优化 1</strong>：利用 Project 1 的 Buffer Pool，做 <strong>Block Nested Loop Join</strong>，每次读一个 Page 的数据进缓存比较，减少 I/O 次数。</li>
<li><strong>优化 2</strong>：如果内层表有我们在 Project 2 建的 B+ 树，直接走 <strong>Index Nested Loop Join</strong>，性能提升是数量级的。</li>
</ul>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象算子基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractExecutor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Next</span><span class="params">(<span class="type">int</span> *val, <span class="type">int</span> *rid)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序扫描算子 (SeqScan)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqScanExecutor</span> : <span class="keyword">public</span> AbstractExecutor &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SeqScanExecutor</span>(BufferPoolManager *bpm, LockManager *lm, <span class="type">txn_id_t</span> txn_id)</span><br><span class="line">        : <span class="built_in">bpm_</span>(bpm), <span class="built_in">lm_</span>(lm), <span class="built_in">txn_id_</span>(txn_id) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cursor_ = <span class="number">0</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[Executor] SeqScan Init for Txn &quot;</span> &lt;&lt; txn_id_ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次调用只返回一行数据 (Pipeline)</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Next</span><span class="params">(<span class="type">int</span> *val, <span class="type">int</span> *rid)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cursor_ &gt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 假设表里只有3行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 调用 Lock Manager 加锁 (2PL)</span></span><br><span class="line">        lm_-&gt;<span class="built_in">LockRow</span>(txn_id_, LockMode::SHARED, cursor_);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 调用 BPM 获取数据 (这里简化为直接生成)</span></span><br><span class="line">        <span class="comment">// 实际上应该是 bpm_-&gt;FetchPage(...) -&gt; Read Tuple -&gt; Unpin</span></span><br><span class="line">        *val = <span class="number">1000</span> + cursor_;</span><br><span class="line">        *rid = cursor_;</span><br><span class="line"></span><br><span class="line">        cursor_++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cursor_;</span><br><span class="line">    BufferPoolManager *bpm_;</span><br><span class="line">    LockManager *lm_;</span><br><span class="line">    <span class="type">txn_id_t</span> txn_id_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Project-4-Concurrency-Control"><a href="#Project-4-Concurrency-Control" class="headerlink" title="Project 4: Concurrency Control"></a>Project 4: Concurrency Control</h2><p>最后一个项目是将前面所有模块串联起来，让 BusTub 支持事务（Transaction）。</p>
<h3 id="1-锁管理器"><a href="#1-锁管理器" class="headerlink" title="1. 锁管理器"></a>1. 锁管理器</h3><p>所有的锁请求（S锁读，X锁写）都要经过 Lock Manager。为了提高并发度，BusTub 支持<strong>意向锁 (Intention Locks, IS/IX)</strong>。 这允许我们在“表”级别加意向锁，在“行”级别加实际锁。这样当我想锁整张表时，不需要去遍历每一行看有没有被锁，直接看表头有没有意向锁即可。</p>
<h3 id="2-2PL-两阶段锁协议"><a href="#2-2PL-两阶段锁协议" class="headerlink" title="2. 2PL (两阶段锁协议)"></a>2. 2PL (两阶段锁协议)</h3><p>为了保证 Serializability（可串行化），我严格遵循 <strong>2PL</strong>：</p>
<ul>
<li><strong>Growing Phase</strong>：疯狂加锁，不能释放。</li>
<li><strong>Shrinking Phase</strong>：一旦释放一把锁，就不能再加锁。</li>
</ul>
<p>为了防止<strong>级联回滚 (Cascading Aborts)</strong>，我实现了 <strong>Strict 2PL</strong>，即所有的写锁（X锁）必须坚持到事务 Commit 或 Abort 的最后一刻才释放。</p>
<h3 id="3-死锁检测"><a href="#3-死锁检测" class="headerlink" title="3. 死锁检测"></a>3. 死锁检测</h3><p>有了锁，就一定会有死锁。由于 Latch 很轻量我们不检测，但 Lock 的死锁必须解决。 我写了一个后台线程，定期构建 <strong>Wait-for Graph</strong>（等待图）。</p>
<ul>
<li>图的节点是事务，边代表“我在等你释放锁”。</li>
<li>如果图里出现了<strong>环 (Cycle)</strong>，说明死锁了。</li>
<li><strong>破局</strong>：DFS 找环，找到后选择一个“最年轻”的事务作为倒霉蛋（Victim），强制 Abort 它，释放它的资源让其他人通过。</li>
</ul>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">LockMode</span> &#123; SHARED, EXCLUSIVE &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockManager</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 申请行锁</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">LockRow</span><span class="params">(<span class="type">txn_id_t</span> txn_id, LockMode mode, <span class="type">int</span> row_id)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 简单的模拟：直接打印日志，假设总是成功</span></span><br><span class="line">        <span class="comment">// 真实的 15-445 这里需要维护 Wait-for Graph 和 Condition Variable</span></span><br><span class="line">        string mode_str = (mode == LockMode::SHARED) ? <span class="string">&quot;S (Read)&quot;</span> : <span class="string">&quot;X (Write)&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[LockMgr] Txn &quot;</span> &lt;&lt; txn_id &lt;&lt; <span class="string">&quot; request &quot;</span> &lt;&lt; mode_str &lt;&lt; <span class="string">&quot; Lock on Row &quot;</span> &lt;&lt; row_id &lt;&lt; <span class="string">&quot;... GRANTED.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        lock_table_[row_id].<span class="built_in">push_back</span>(txn_id);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放行锁</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UnlockRow</span><span class="params">(<span class="type">txn_id_t</span> txn_id, <span class="type">int</span> row_id)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[LockMgr] Txn &quot;</span> &lt;&lt; txn_id &lt;&lt; <span class="string">&quot; released Lock on Row &quot;</span> &lt;&lt; row_id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex latch_;</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, std::vector&lt;<span class="type">txn_id_t</span>&gt;&gt; lock_table_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结与思考"><a href="#总结与思考" class="headerlink" title="总结与思考"></a>总结与思考</h2><p>通关 CMU 15-445 是一次痛并快乐的经历。</p>
<ol>
<li><strong>C++ 的 RAII 是把双刃剑</strong>：虽然智能指针方便，但在底层系统中，为了极致性能或复杂的生命周期管理（如 Buffer Pool），有时候不得不裸用指针，这时候 manual memory management 就极其考验功力。</li>
<li><strong>调试并发代码</strong>：单测（GTest）跑过了不代表没 Bug。Project 2 和 4 中，很多 Bug 只有在多线程高压测试下才会偶现。学会使用 sanitizer 和分析 core dump 是必备技能。</li>
<li><strong>系统设计的权衡</strong>：从 LRU-K 的参数选择，到 B+ 树乐观锁的策略，数据库内核里没有绝对的最优解，只有在特定场景下的最合适的 Trade-off。</li>
</ol>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Sakuya_maid</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/09/15/CMU15-445%E7%9A%84%E5%AD%A6%E4%B9%A0/">http://example.com/2025/09/15/CMU15-445%E7%9A%84%E5%AD%A6%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Sakuya的算法基地</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%A0%91%E8%AE%BA/">树论</a><a class="post-meta__tags" href="/tags/B-Tree/">B+ Tree</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><a class="post-meta__tags" href="/tags/%E9%94%81/">锁</a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></div><div class="post-share"><div class="social-share" data-image="/img/e69f040cf614d996afe704ea41c637ab.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2026/01/16/%E7%AC%AC%E4%B8%80%E7%AF%87%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/" title="CF1107F Vasya and Endless Credits 题解"><img class="cover" src="/img/df0b4c5eb607b0c10b1c47a4076ea836.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">CF1107F Vasya and Endless Credits 题解</div></div><div class="info-2"><div class="info-item-1">CF1107F Vasya and Endless Credits题目描述Vasya 想给自己买一辆漂亮的新车。不幸的是，他手头缺钱。目前他正好有 $0$ 布尔。 然而，当地银行有 $n$ 个信贷产品。每个产品可以用三个数字 $a_i$、$b_i$ 和 $k_i$ 来描述。产品编号从 $1$ 到 $n$。如果 Vasya 选择第 $i$ 个产品，那么银行会在本月初给他 $a_i$ 布尔，然后在接下来的 $k_i$ 个月（包括激活该产品的当月）里，每个月月底 Vasya 都要向银行支付 $b_i$ 布尔。Vasya 可以按任意顺序选择这些信贷产品。 每个月 Vasya 最多只能选择一个信贷产品。每个信贷产品也只能使用一次。多个信贷产品可以同时处于激活状态。这意味着，每个月底 Vasya 需要向银行支付所有处于激活状态的信贷产品的 $b_i$ 之和。 Vasya 想在某个月的中旬买车。他会把自己当前拥有的所有钱拿出来，买一辆正好这个价格的车。 Vasya 并不关心买车后还要还银行多少钱。他会开着车离开这个国家，这样银行就再也找不到他了。 请问，这辆车的最大价格是多少？ 输入格式第一行...</div></div></div></a><a class="pagination-related" href="/2024/10/03/%E7%BD%91%E7%BB%9C%E6%B5%81%E4%B8%93%E9%A2%98/" title="网络流学习记录"><img class="cover" src="/img/1f33d5d68b634ac02d9fda701256f04a.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">网络流学习记录</div></div><div class="info-2"><div class="info-item-1">1. 行列建图因为行列的约束关系，即一次操作可以同时满足两者，对行到列建边后跑最大流即为最小代价。 洛谷 P6931这题要求满足符合原本三视图的视角情况下，移走尽可能多的箱子。  按照俯视图，可以把 $\ge 1$ 的箱子移到只剩下一个箱子，这是满足俯视图的情况。 侧视图和主视图可以通过对行和列取 $\max$ 求得。  一个很自然的想法是就留下这些箱子，其他全部移走，但是其实还能优化。就是一个柱子所在的行和所在的列如果高度一样的时候，可以不需要两根柱子，又能移走他们的一座高度。这里建图就是在俯视图那个位置有箱子的情况下，并且那个位置的侧视图和主视图高度一样的情况下，可以把 $i$ 作为二分图的左部点，$j$ 作为二分图的右部点，跑出来的最大流就是可以继续移走的箱子。 洛谷 P2825这题和上题一样，也是炸弹可以炸到行和列，和上一题关键柱子占了行和列是一模一样的，都是要求尽可能多，行对列建图后跑最大流即可。 洛谷 P7368这题也是，消除某一行或者某一列都可以达成目标，即在对行列建完二分图后将题目要求转为求最小割，中间连 $INF$ 的点确保不会被割即可。  2. 基于整体关系转...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/jk.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Sakuya_maid</div><div class="author-info-description">ACMer / 二次元 / 莫妮卡厨 / 车万</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/DDLC-Monika"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E6%A0%B8%EF%BC%9ACMU-15-445-BusTub-%E5%A4%8D%E7%9B%98"><span class="toc-number">1.</span> <span class="toc-text">手写数据库内核：CMU 15-445 (BusTub) 复盘</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Project-1-Buffer-Pool-Manager"><span class="toc-number">1.1.</span> <span class="toc-text">Project 1: Buffer Pool Manager</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E6%8C%91%E6%88%98%EF%BC%9ALRU-K-%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. 核心挑战：LRU-K 置换算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E4%B8%8E-Pin-Unpin-%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. 内存映射与 Pin&#x2F;Unpin 机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Project-2-B-Tree-Index"><span class="toc-number">1.2.</span> <span class="toc-text">Project 2: B+ Tree Index</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 数据结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Latch-Crabbing"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. Latch Crabbing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Project-3-Query-Execution"><span class="toc-number">1.3.</span> <span class="toc-text">Project 3: Query Execution</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E2%80%9C%E6%8B%89%E5%8F%96%E5%BC%8F%E2%80%9C%E6%89%A7%E8%A1%8C%E6%B5%81"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. “拉取式“执行流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Join-%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. Join 的优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Project-4-Concurrency-Control"><span class="toc-number">1.4.</span> <span class="toc-text">Project 4: Concurrency Control</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%94%81%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">1. 锁管理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2PL-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.4.2.</span> <span class="toc-text">2. 2PL (两阶段锁协议)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="toc-number">1.4.3.</span> <span class="toc-text">3. 死锁检测</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E6%80%9D%E8%80%83"><span class="toc-number">1.5.</span> <span class="toc-text">总结与思考</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/01/16/%E7%AC%AC%E4%B8%80%E7%AF%87%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/" title="CF1107F Vasya and Endless Credits 题解"><img src="/img/df0b4c5eb607b0c10b1c47a4076ea836.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CF1107F Vasya and Endless Credits 题解"/></a><div class="content"><a class="title" href="/2026/01/16/%E7%AC%AC%E4%B8%80%E7%AF%87%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/" title="CF1107F Vasya and Endless Credits 题解">CF1107F Vasya and Endless Credits 题解</a><time datetime="2026-01-16T02:00:00.000Z" title="发表于 2026-01-16 10:00:00">2026-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/15/CMU15-445%E7%9A%84%E5%AD%A6%E4%B9%A0/" title="CMU15-445的学习"><img src="/img/e69f040cf614d996afe704ea41c637ab.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CMU15-445的学习"/></a><div class="content"><a class="title" href="/2025/09/15/CMU15-445%E7%9A%84%E5%AD%A6%E4%B9%A0/" title="CMU15-445的学习">CMU15-445的学习</a><time datetime="2025-09-15T02:00:00.000Z" title="发表于 2025-09-15 10:00:00">2025-09-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/03/%E7%BD%91%E7%BB%9C%E6%B5%81%E4%B8%93%E9%A2%98/" title="网络流学习记录"><img src="/img/1f33d5d68b634ac02d9fda701256f04a.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="网络流学习记录"/></a><div class="content"><a class="title" href="/2024/10/03/%E7%BD%91%E7%BB%9C%E6%B5%81%E4%B8%93%E9%A2%98/" title="网络流学习记录">网络流学习记录</a><time datetime="2024-10-03T08:53:04.000Z" title="发表于 2024-10-03 16:53:04">2024-10-03</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By Sakuya_maid</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4-b1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4-b1"></script><script src="/js/main.js?v=5.5.4-b1"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        loader: {
          load: [
            // Four font extension packages (optional)
            //- '[tex]/bbm',
            //- '[tex]/bboldx',
            //- '[tex]/dsfont',
            '[tex]/mhchem'
          ],
          paths: {
            'mathjax-newcm': '[mathjax]/../@mathjax/mathjax-newcm-font',

            //- // Four font extension packages (optional)
            //- 'mathjax-bbm-extension': '[mathjax]/../@mathjax/mathjax-bbm-font-extension',
            //- 'mathjax-bboldx-extension': '[mathjax]/../@mathjax/mathjax-bboldx-font-extension',
            //- 'mathjax-dsfont-extension': '[mathjax]/../@mathjax/mathjax-dsfont-font-extension',
            'mathjax-mhchem-extension': '[mathjax]/../@mathjax/mathjax-mhchem-font-extension'
          }
        },
        output: {
          font: 'mathjax-newcm',
        },
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
          packages: {
            '[+]': [
              'mhchem'
            ]
          }
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          menuOptions: {
            settings: {
              enrich: false  // Turn off Braille and voice narration text automatic generation
            }
          },
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@4.0.0/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>